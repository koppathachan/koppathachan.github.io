<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Memoization, with a js implementation that caches recursive calls | Akhil Sasidharan</title>
<meta name=keywords content="functionalprogramming,lambdacalculus,javascript,js,memoization,memoizer,recursion,fastrecursion">
<meta name=description content="Memoization is an optimization technique used in functional programming to speed up execution by storing the results of resource expensive function calls. When the function is called again with the same input the stored result is fetched and returned. This is possible in functional programming languages because of the use of pure functions as discussed in this post. Purely functional languages such as Haskell has inbuilt support for memoization. In javascript, using a mutable map (object, map, caches) we can implement a memoization.">
<meta name=author content="Akhil Sasidharan">
<link rel=canonical href=https://akhilsasidharan.in/tech/fast-recursion-using-memoizer/>
<link crossorigin=anonymous href=../../assets/css/stylesheet.min.6f60056d44d3f7eb69a4bc6c332b59960f3a995802bded244750232f33713c49.css integrity="sha256-b2AFbUTT9+tppLxsMytZlg86mVgCve0kR1AjLzNxPEk=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=../../assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://akhilsasidharan.in/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://akhilsasidharan.in/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://akhilsasidharan.in/favicon-32x32.png>
<link rel=apple-touch-icon href=https://akhilsasidharan.in/apple-touch-icon.png>
<link rel=mask-icon href=https://akhilsasidharan.in/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.89.2">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="Memoization, with a js implementation that caches recursive calls">
<meta property="og:description" content="Memoization is an optimization technique used in functional programming to speed up execution by storing the results of resource expensive function calls. When the function is called again with the same input the stored result is fetched and returned. This is possible in functional programming languages because of the use of pure functions as discussed in this post. Purely functional languages such as Haskell has inbuilt support for memoization. In javascript, using a mutable map (object, map, caches) we can implement a memoization.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://akhilsasidharan.in/tech/fast-recursion-using-memoizer/"><meta property="og:image" content="https://akhilsasidharan.in"><meta property="article:section" content="tech">
<meta property="article:published_time" content="2020-09-20T23:50:30+05:30">
<meta property="article:modified_time" content="2021-11-08T23:52:39+05:30"><meta property="og:site_name" content="Akhil Sasidharan">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://akhilsasidharan.in">
<meta name=twitter:title content="Memoization, with a js implementation that caches recursive calls">
<meta name=twitter:description content="Memoization is an optimization technique used in functional programming to speed up execution by storing the results of resource expensive function calls. When the function is called again with the same input the stored result is fetched and returned. This is possible in functional programming languages because of the use of pure functions as discussed in this post. Purely functional languages such as Haskell has inbuilt support for memoization. In javascript, using a mutable map (object, map, caches) we can implement a memoization.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Tech","item":"https://akhilsasidharan.in/tech/"},{"@type":"ListItem","position":3,"name":"Memoization, with a js implementation that caches recursive calls","item":"https://akhilsasidharan.in/tech/fast-recursion-using-memoizer/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Memoization, with a js implementation that caches recursive calls","name":"Memoization, with a js implementation that caches recursive calls","description":"Memoization is an optimization technique used in functional programming to speed up execution by storing the results of resource expensive function calls. When the function is called again with the same input the stored result is fetched and returned. This is possible in functional programming languages because of the use of pure functions as discussed in this post. Purely functional languages such as Haskell has inbuilt support for memoization. In javascript, using a mutable map (object, map, caches) we can implement a memoization.","keywords":["functionalprogramming","lambdacalculus","javascript","js","memoization","memoizer","recursion","fastrecursion"],"articleBody":"Memoization is an optimization technique used in functional programming to speed up execution by storing the results of resource expensive function calls. When the function is called again with the same input the stored result is fetched and returned. This is possible in functional programming languages because of the use of pure functions as discussed in this post. Purely functional languages such as Haskell has inbuilt support for memoization. In javascript, using a mutable map (object, map, caches) we can implement a memoization.\nMemoization is especially useful in recursive functions. Writing code the functional way makes my code expressive and testable. However, as I will demonstrate now, in javascript (and most other impure functional languages) recursion is horrendously slow. Recursion is essential to functional programming.\nLet’s look at the fibonacci series. The mathematical formula of which is,\nFn = Fn-1 + Fn-2, where F0 = 0, F1 = 1\nor\nFn = Fn-1 + Fn-2, when n  1, and\nFn = n, when n Looking at this equation one can see why recursive function appeals here. Look at the analogous js code.\n\nconst fib = (n) = n  1 ? fib(n - 1) + fib(n - 2) : n; To calculate the fibonacci of 40 the above function took more than a second. Beyond fibonacci of 50 the output depends on what video I am playing on my laptop. The non recursive but super fast code looks like this.\n 1 2 3 4 5 6 7 8 9 10  const uglyFib = (n) = { let a = 0, b = 1, c, i; if (n == 0) return a; for (i = 2; i  n; i++) { c = a + b; // We violate immutability rule here  a = b; // and here  b = c; // and here  } return b; };  \nIt doesn’t look anything like its mathematical representation. I wished it had the charming good looks of its recursive counterpart to go with its dashing performance. That wish was granted; we have memoization.\nBut first let me show you what happens while calculating the fibonacci value of 5. fib(5).\n\nfib(5) | +--fib(4) | | | +--fib(3)-------------------------------1 | | | | | | +--fib(2)-----------------1 | | | | | | | | | | *--fib(1) | | | | | | | | | | | *--fib(0) | | | | | | | | | +--fib(1) | | | | | | | +--fib(2)--------------------2 | | | | | | *--fib(1) | | | | | | | *--fib(0) | | +--fib(3)-----------------------|----------2 | | | | +--fib(2)--------------------3 | | | | | *--fib(1) | | | | | *--fib(1) | | | +--fib(1) From the above tree we can see that fib(3) is called 2 times, fib(2) is called 3 times, fib(1) 6 times and fib(0) 2 times. Memoization is how we avoid these repeated calls by saving the result the first time fib(n) is called. When the result is returned its value is cached in an object with the key as the functions input (n in this case). This can be reused by subsequent calls to the function with the same input.\nLet’s look at a basic implementation of memoization.\n 1 2 3 4 5 6 7 8  const fibonacci = (n, memo = {}) { // provide a default object as \t// cache.  if (memo[n]) { return memo[n]; } // looking in the cache.  if (n  1) { return 1; } memo[n] = fibonacci(n - 1, memo) + // save the result and pass the \tfibonacci(n - 2, memo); // cache object.  return memo[n]; // return the result  }  \nThe above implementation not only caches the result of fibonacci(5), but also intermediate results of fibonacci(4), fibonacci(3) and all the rest of them.\nSome npm modules like fast-memoize and memoize provide generic implementations to memoize any function like this.\n 1 2 3 4 5  const memoize = require('fast-memoize') const fn = function (one, two, three) { /* ... */ } const memoized = memoize(fn) memoized('foo', 3, 'bar') memoized('foo', 3, 'bar') // Cache hit   \nBut they do not cache intermediate results like we saw above in the custom implementation. While I do like custom implementations over a generic solution, I attempted a generic solution that caches intermediate values. That is, if I call fib(5) the memoized value of fib(5) will cache fib(4), fib(3), fib(2), fib(1), fib(0) before the function fib(5) has returned, which is speeds up some recursive functions.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  export const memoize = (func, cache = Object.create(null)) = { // here we do some magic to sanitize body and arguments recieved from  // the func.toString() call. Then we return a new function as shown  // below.  return new Function('cache', ` return function ${func.name}(${args}) { let result = cache[JSON.stringify([${args}])] if (result) { return result; } result = ${body}cache[JSON.stringify([${args}])] = result; return result; } `)(cache); };  \nNot an elegant solution admittedly, but it does the job, given the limitations of javascript. You can explore the full code at https://github.com/sasidakh/memoizer.\nI tested this implementation where the fibonacci of 40 was calculated and it was only 4 times slower (the first time it was called) than its non recursive counter part as opposed to being nearly 40000 times slower.\n   Without recursion : : x     With recursion : : ~ 39000x slower   Memoized recursion : : ~4x slower   Memoized recursion ran twice : : ~42x faster    Wo-hoo! My code is faster thanks to memoization\nYou can run the tests on the repo to understand it better.\n","wordCount":"939","inLanguage":"en","datePublished":"2020-09-20T23:50:30+05:30","dateModified":"2021-11-08T23:52:39+05:30","author":[{"@type":"Person","name":"Akhil Sasidharan"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://akhilsasidharan.in/tech/fast-recursion-using-memoizer/"},"publisher":{"@type":"Organization","name":"Akhil Sasidharan","logo":{"@type":"ImageObject","url":"https://akhilsasidharan.in/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://akhilsasidharan.in accesskey=h title="Akhil Sasidharan (Alt + H)">Akhil Sasidharan</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://akhilsasidharan.in/tech/ title=Tech>
<span>Tech</span>
</a>
</li>
<li>
<a href=https://akhilsasidharan.in/poems/ title=Poems>
<span>Poems</span>
</a>
</li>
<li>
<a href=https://akhilsasidharan.in/categories/ title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=https://akhilsasidharan.in/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://akhilsasidharan.in/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://akhilsasidharan.in>Home</a>&nbsp;»&nbsp;<a href=https://akhilsasidharan.in/tech/>Tech</a></div>
<h1 class=post-title>
Memoization, with a js implementation that caches recursive calls
</h1>
<div class=post-meta><span title="2020-09-20 23:50:30 +0530 IST">September 20, 2020</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Akhil Sasidharan
</div>
</header>
<div class=post-content><p>Memoization is an <strong>optimization technique</strong> used in functional
programming to speed up execution by storing the results of resource
expensive function calls. When the function is called again with the
same input the stored result is fetched and returned. This is possible
in functional programming languages because of the use of <strong>pure
functions</strong> as discussed in this <a href=https://akhilsasidharan.in/tech/functional-programming/>post</a>. Purely functional languages such
as Haskell has inbuilt support for memoization. In javascript, using a
mutable map (object, map, caches) we can implement a memoization.</p>
<p>Memoization is especially useful in recursive functions. Writing code
the functional way makes my code expressive and testable. However, as
I will demonstrate now, in javascript (and most other impure
functional languages) recursion is horrendously slow. Recursion is
essential to functional programming.</p>
<p>Let&rsquo;s look at the <strong>fibonacci series</strong>. The mathematical formula of
which is,</p>
<p>F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub>, where F<sub>0</sub> = 0, F<sub>1</sub> = 1</p>
<p>or</p>
<p>F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub>, when n > 1, and</p>
<p>F<sub>n</sub> = n, when n &lt;= 1</p>
<p>Looking at this equation one can see why recursive function appeals
here. Look at the analogous js code.</p>
<p><a id=code-snippet--EgFibRec></a></p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js>  <span class=kr>const</span> <span class=nx>fib</span> <span class=o>=</span> <span class=p>(</span><span class=nx>n</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>n</span> <span class=o>&gt;</span> <span class=mi>1</span> <span class=o>?</span> <span class=nx>fib</span><span class=p>(</span><span class=nx>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=nx>fib</span><span class=p>(</span><span class=nx>n</span> <span class=o>-</span> <span class=mi>2</span><span class=p>)</span> <span class=o>:</span> <span class=nx>n</span><span class=p>;</span>
</code></pre></div><p>To calculate the fibonacci of 40 the above function took more than a
second. Beyond fibonacci of 50 the output depends on what video I am
playing on my laptop. The non recursive but super fast code looks like
this.</p>
<p><a id=code-snippet--EgFib></a>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-js data-lang=js>  <span class=kr>const</span> <span class=nx>uglyFib</span> <span class=o>=</span> <span class=p>(</span><span class=nx>n</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
      <span class=kd>let</span> <span class=nx>a</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>b</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=nx>c</span><span class=p>,</span> <span class=nx>i</span><span class=p>;</span>
      <span class=k>if</span> <span class=p>(</span><span class=nx>n</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=nx>a</span><span class=p>;</span>
      <span class=k>for</span> <span class=p>(</span><span class=nx>i</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
      <span class=nx>c</span> <span class=o>=</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span><span class=p>;</span>  <span class=c1>// We violate immutability rule here
</span><span class=c1></span>      <span class=nx>a</span> <span class=o>=</span> <span class=nx>b</span><span class=p>;</span>      <span class=c1>// and here
</span><span class=c1></span>      <span class=nx>b</span> <span class=o>=</span> <span class=nx>c</span><span class=p>;</span>      <span class=c1>// and here
</span><span class=c1></span>      <span class=p>}</span>
      <span class=k>return</span> <span class=nx>b</span><span class=p>;</span>
  <span class=p>};</span></code></pre></td></tr></table>
</div>
</div></p>
<p>It doesn&rsquo;t look anything like its mathematical representation. I
wished it had the charming good looks of its recursive counterpart to
go with its dashing performance. That wish was granted; we
have memoization.</p>
<p>But first let me show you what happens while calculating the fibonacci
value of 5. fib(5).</p>
<p><a id=code-snippet--Fib5Tree></a></p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>fib(5)
|
+--fib(4)
|  |
|  +--fib(3)-------------------------------1
|  |  |                                    |
|  |  +--fib(2)-----------------1          |
|  |  |  |                      |          |
|  |  |  *--fib(1)              |          |
|  |  |  |                      |          |
|  |  |  *--fib(0)              |          |
|  |  |                         |          |
|  |  +--fib(1)                 |          |
|  |                            |          |
|  +--fib(2)--------------------2          |
|     |                         |          |
|     *--fib(1)                 |          |
|     |                         |          |
|     *--fib(0)                 |          |
+--fib(3)-----------------------|----------2
|  |                            |
|  +--fib(2)--------------------3
|  |  |
|  |  *--fib(1)
|  |  |
|  |  *--fib(1)
|  |
|  +--fib(1)
</code></pre></div><p>From the above tree we can see that fib(3) is called 2 times, fib(2)
is called 3 times, fib(1) 6 times and fib(0) 2 times. Memoization is
how we avoid these repeated calls by saving the result the first time
fib(n) is called. When the result is returned its value is cached in
an object with the key as the functions input (n in this case). This
can be reused by subsequent calls to the function with the same input.</p>
<p>Let&rsquo;s look at a basic implementation of memoization.</p>
<p><a id=code-snippet--EgMemoizedFib></a>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-js data-lang=js>  <span class=kr>const</span> <span class=nx>fibonacci</span> <span class=o>=</span> <span class=p>(</span><span class=nx>n</span><span class=p>,</span> <span class=nx>memo</span> <span class=o>=</span> <span class=p>{})</span> <span class=p>{</span>   <span class=c1>// provide a default object as
</span><span class=c1></span>				       <span class=c1>// cache.
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nx>memo</span><span class=p>[</span><span class=nx>n</span><span class=p>])</span> <span class=p>{</span> <span class=k>return</span> <span class=nx>memo</span><span class=p>[</span><span class=nx>n</span><span class=p>];</span> <span class=p>}</span>   <span class=c1>// looking in the cache.
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nx>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=mi>1</span><span class=p>;</span> <span class=p>}</span>
    <span class=nx>memo</span><span class=p>[</span><span class=nx>n</span><span class=p>]</span> <span class=o>=</span> <span class=nx>fibonacci</span><span class=p>(</span><span class=nx>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=nx>memo</span><span class=p>)</span> <span class=o>+</span> <span class=c1>// save the result and pass the
</span><span class=c1></span>	      <span class=nx>fibonacci</span><span class=p>(</span><span class=nx>n</span> <span class=o>-</span> <span class=mi>2</span><span class=p>,</span> <span class=nx>memo</span><span class=p>);</span>  <span class=c1>// cache object.
</span><span class=c1></span>    <span class=k>return</span> <span class=nx>memo</span><span class=p>[</span><span class=nx>n</span><span class=p>];</span>                    <span class=c1>// return the result
</span><span class=c1></span>  <span class=p>}</span></code></pre></td></tr></table>
</div>
</div></p>
<p>The above implementation not only caches the result of fibonacci(5),
but also intermediate results of fibonacci(4), fibonacci(3) and all
the rest of them.</p>
<p>Some npm modules like fast-memoize and memoize provide generic
implementations to memoize any function like this.</p>
<p><a id=code-snippet--EgMemoizedFib></a>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-js data-lang=js>  <span class=kr>const</span> <span class=nx>memoize</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;fast-memoize&#39;</span><span class=p>)</span>
  <span class=kr>const</span> <span class=nx>fn</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>(</span><span class=nx>one</span><span class=p>,</span> <span class=nx>two</span><span class=p>,</span> <span class=nx>three</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* ... */</span> <span class=p>}</span>
  <span class=kr>const</span> <span class=nx>memoized</span> <span class=o>=</span> <span class=nx>memoize</span><span class=p>(</span><span class=nx>fn</span><span class=p>)</span>
  <span class=nx>memoized</span><span class=p>(</span><span class=s1>&#39;foo&#39;</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=s1>&#39;bar&#39;</span><span class=p>)</span>
  <span class=nx>memoized</span><span class=p>(</span><span class=s1>&#39;foo&#39;</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=s1>&#39;bar&#39;</span><span class=p>)</span> <span class=c1>// Cache hit
</span></code></pre></td></tr></table>
</div>
</div></p>
<p>But they do not cache intermediate results like we saw above in the
custom implementation. While I do like custom implementations over a
generic solution, I attempted a generic solution that caches
intermediate values. That is, if I call fib(5) the memoized value of
fib(5) will cache fib(4), fib(3), fib(2), fib(1), fib(0) before the
function fib(5) has returned, which is speeds up some recursive
functions.</p>
<p><a id=code-snippet--EgMemoizedFib></a>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-js data-lang=js>  <span class=kr>export</span> <span class=kr>const</span> <span class=nx>memoize</span> <span class=o>=</span> <span class=p>(</span><span class=nx>func</span><span class=p>,</span> <span class=nx>cache</span> <span class=o>=</span> <span class=nb>Object</span><span class=p>.</span><span class=nx>create</span><span class=p>(</span><span class=kc>null</span><span class=p>))</span> <span class=p>=&gt;</span> <span class=p>{</span>

  <span class=c1>// here we do some magic to sanitize body and arguments recieved from
</span><span class=c1></span>  <span class=c1>// the func.toString() call. Then we return a new function as shown
</span><span class=c1></span>  <span class=c1>// below.
</span><span class=c1></span>
    <span class=k>return</span> <span class=k>new</span> <span class=nb>Function</span><span class=p>(</span><span class=s1>&#39;cache&#39;</span><span class=p>,</span>
  <span class=sb>`
</span><span class=sb>  return function </span><span class=si>${</span><span class=nx>func</span><span class=p>.</span><span class=nx>name</span><span class=si>}</span><span class=sb> (</span><span class=si>${</span><span class=nx>args</span><span class=si>}</span><span class=sb>) {
</span><span class=sb>    let result = cache[JSON.stringify([</span><span class=si>${</span><span class=nx>args</span><span class=si>}</span><span class=sb>])]
</span><span class=sb>    if (result) { return result; }
</span><span class=sb>    result = </span><span class=si>${</span><span class=nx>body</span><span class=si>}</span><span class=sb>
</span><span class=sb>    cache[JSON.stringify([</span><span class=si>${</span><span class=nx>args</span><span class=si>}</span><span class=sb>])] = result;
</span><span class=sb>    return result;
</span><span class=sb>  }
</span><span class=sb>  `</span><span class=p>)(</span><span class=nx>cache</span><span class=p>);</span>
  <span class=p>};</span></code></pre></td></tr></table>
</div>
</div></p>
<p>Not an elegant solution admittedly, but it does the job, given the
limitations of javascript. You can explore the full code at
<a href=https://github.com/sasidakh/memoizer>https://github.com/sasidakh/memoizer</a>.</p>
<p>I tested this implementation where the fibonacci of 40 was calculated
and it was only 4 times slower (the first time it was called) than its
non recursive counter part as opposed to being nearly 40000 times
slower.</p>
<table>
<thead>
<tr>
<th>Without recursion</th>
<th>:</th>
<th>:</th>
<th>x</th>
</tr>
</thead>
<tbody>
<tr>
<td>With recursion</td>
<td>:</td>
<td>:</td>
<td>~ 39000x slower</td>
</tr>
<tr>
<td>Memoized recursion</td>
<td>:</td>
<td>:</td>
<td>~4x slower</td>
</tr>
<tr>
<td>Memoized recursion ran twice</td>
<td>:</td>
<td>:</td>
<td>~42x faster</td>
</tr>
</tbody>
</table>
<p><strong>Wo-hoo! My code is faster thanks to memoization</strong></p>
<p>You can run the tests on the <a href=https://github.com/sasidakh/memoizer>repo</a> to understand it better.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://akhilsasidharan.in/tags/functionalprogramming/>functionalprogramming</a></li>
<li><a href=https://akhilsasidharan.in/tags/lambdacalculus/>lambdacalculus</a></li>
<li><a href=https://akhilsasidharan.in/tags/javascript/>javascript</a></li>
<li><a href=https://akhilsasidharan.in/tags/js/>js</a></li>
<li><a href=https://akhilsasidharan.in/tags/memoization/>memoization</a></li>
<li><a href=https://akhilsasidharan.in/tags/memoizer/>memoizer</a></li>
<li><a href=https://akhilsasidharan.in/tags/recursion/>recursion</a></li>
<li><a href=https://akhilsasidharan.in/tags/fastrecursion/>fastrecursion</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://akhilsasidharan.in/tech/prefer-native-over-library/>
<span class=title>« Prev Page</span>
<br>
<span>Why use native Promise over Bluebird and other implementations</span>
</a>
<a class=next href=https://akhilsasidharan.in/tech/functional-programming/>
<span class=title>Next Page »</span>
<br>
<span>Functional Programming</span>
</a>
</nav>
</footer><div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//akhilsasidharan-in.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://akhilsasidharan.in>Akhil Sasidharan</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>